#!/usr/bin/env bash
# analyze_office_menu_with_llm_with_error.sh — menu + LLM prompt option + error display

set -euo pipefail
IFS=$'\n'

LOGFILE="script-run.log"
ANALYSIS_LOG="analysis-results.log"
OUTDIR="out"

GEMINI_API_KEY="YOUR_GOOGLE_GEMINI_API_KEY"
GEMINI_ENDPOINT="https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent"

exec > >(tee -a "$LOGFILE") 2>&1

echo "────────────────────────────────────────────────────────"
echo "Office Analysis & LLM Menu — $(date)"
echo "Run log: $LOGFILE"
echo "Analysis log: $ANALYSIS_LOG"
echo "────────────────────────────────────────────────────────"

if [[ $# -lt 1 ]]; then
  echo "Usage: $0 path/to/data.(xlsx|csv) [sheet_name_or_index if xlsx]"
  exit 1
fi

SRC="$1"
EXCEL_SHEET="${2:-}"

if [[ ! -f "$SRC" ]]; then
  echo "ERROR: File not found: $SRC"
  exit 1
fi

mkdir -p "$OUTDIR"

if ! command -v duckdb >/dev/null 2>&1; then
  echo "ERROR: duckdb CLI not installed"
  exit 1
fi
if ! command -v jq >/dev/null 2>&1; then
  echo "ERROR: jq is required to parse JSON responses. Install it (e.g. brew install jq)."
  exit 1
fi

# Column names
COL_SALE_DATE="SaleDate"
COL_SALE_AMOUNT="SaleAmount"
COL_GROSS_AREA="GrossArea"
COL_BUILDING_VALUE="BuildingValue"
COL_LAND_VALUE="LandValue"
COL_YEAR_BUILT="YearBuilt"
COL_CITY="SiteCity"
COL_ZIP="SiteZIP"
COL_OWNER="OwnerName"
COL_LAND_CODE="LandCode"
COL_TOTAL_VALUE="TotalLivingArea"

note () { echo "$*" | tee -a "$ANALYSIS_LOG" >/dev/null; }
sql_quote() { printf "%s" "$1" | sed "s/'/''/g"; }

EXT="${SRC##*.}"
EXT_LOWER="$(printf "%s" "$EXT" | tr '[:upper:]' '[:lower:]')"
SRC_ESCAPED="$(sql_quote "$SRC")"

make_load_prelude() {
  if [[ "$EXT_LOWER" == "xlsx" ]]; then
    if [[ -n "$EXCEL_SHEET" ]]; then
      SHEET_CLAUSE=", sheet = '$(sql_quote "$EXCEL_SHEET")'"
    else
      SHEET_CLAUSE=""
    fi
    cat <<SQL
PRAGMA disable_progress_bar;
SET threads TO 4;
INSTALL excel;
LOAD excel;
CREATE OR REPLACE VIEW v_all AS
SELECT *
FROM read_xlsx('$SRC_ESCAPED'${SHEET_CLAUSE}, header = true, ignore_errors = true);
SQL
  else
    cat <<SQL
PRAGMA disable_progress_bar;
SET threads TO 4;
CREATE OR REPLACE VIEW v_all AS
SELECT *
FROM read_csv_auto('$SRC_ESCAPED', header = true, sample_size = -1, nullstr = '');
SQL
  fi
}

# Metadata
echo "Loading dataset and showing metadata..."
duckdb <<SQL
$(make_load_prelude)
SELECT COUNT(*) AS total_rows FROM v_all;
PRAGMA table_info('v_all');
SELECT * FROM v_all LIMIT 1 OFFSET 1;
SELECT * FROM v_all
ORDER BY TRY_CAST("$COL_SALE_DATE" AS DATE) DESC NULLS LAST
LIMIT 1;
.quit
SQL

echo "Data loaded. Choose a scenario or LLM prompt."

while true; do
  echo
  echo "Menu:"
  echo "  1) Recent Office Sales & PPSF by Zip/City"
  echo "  2) Top Owners & Portfolios"
  echo "  3) Older Inventory & Value-Add Opportunities"
  echo "  4) Out-of-Area Owners"
  echo "  5) Size Distribution"
  echo "  6) Underperforming Assets"
  echo "  7) Transaction Volume / Hotspots"
  echo "  8) Value Drivers (YearBuilt, Size, etc.)"
  echo "  9) Long-Term Ownership"
  echo "  L) LLM Prompt / Analysis"
  echo "  0) Quit"
  read -p "Enter choice [0-9, L]: " choice

  case "$choice" in
    0)
      echo "Exiting."
      break
      ;;
    L|l)
      echo "--- LLM Analysis Prompt ---"
      read -p "Enter your prompt: " user_prompt
      echo "Sending prompt to LLM..."
      # Send HTTP request, capture status and body
      response_json_and_status=$(curl -s -w "\n%{http_code}" -X POST \
        "$GEMINI_ENDPOINT" \
        -H "Content-Type: application/json" \
        -H "Authorization: Bearer $GEMINI_API_KEY" \
        -d "{\"contents\":[{\"parts\":[{\"text\":\"${user_prompt//\"/\\\"}\"}]}]}"
      )
      # Parse last line as status code, rest as JSON
      http_status=$(echo "$response_json_and_status" | tail -n1)
      response_body=$(echo "$response_json_and_status" | sed '$d')
      if [[ "$http_status" != "200" ]]; then
        echo "ERROR: LLM API returned status $http_status"
        echo "Response body:"
        echo "$response_body"
        echo "Logging error..."
        echo "=== LLM Prompt Error ===" >> "$ANALYSIS_LOG"
        echo "Prompt: $user_prompt" >> "$ANALYSIS_LOG"
        echo "HTTP status: $http_status" >> "$ANALYSIS_LOG"
        echo "Body: $response_body" >> "$ANALYSIS_LOG"
      else
        # Try to extract generated content
        generated=$(echo "$response_body" | jq -r '.candidates[0].content.parts[].text // .candidates[0].content // .candidates[0].text // .text // .result')
        echo "LLM says:"
        echo "--------------------------------------------------"
        echo "$generated"
        echo "--------------------------------------------------"
        echo "Logging prompt and response..."
        echo "=== LLM Prompt ===" >> "$ANALYSIS_LOG"
        echo "$user_prompt" >> "$ANALYSIS_LOG"
        echo "=== LLM Response ===" >> "$ANALYSIS_LOG"
        echo "$generated" >> "$ANALYSIS_LOG"
      fi
      ;;
    1)
      echo "--- Recent Office Sales & PPSF by Zip/City ---"
      duckdb <<SQL
$(make_load_prelude)
COPY (
  WITH base AS (
    SELECT
      "$COL_CITY" AS city,
      "$COL_ZIP" AS zip,
      TRY_CAST("$COL_SALE_DATE" AS DATE) AS sale_dt,
      TRY_CAST(
        REPLACE(
          REPLACE(CAST("$COL_SALE_AMOUNT" AS VARCHAR), ',', ''),
          '$', ''
        ) AS DOUBLE
      ) AS sale_amt,
      TRY_CAST(
        REPLACE(CAST("$COL_GROSS_AREA" AS VARCHAR), ',', '')
        AS DOUBLE
      ) AS gross_sf,
      CASE WHEN gross_sf > 0 THEN sale_amt / gross_sf END AS ppsf
    FROM v_all
    WHERE sale_dt >= date_trunc('day', now()) - INTERVAL '24 months'
      AND sale_amt IS NOT NULL
      AND gross_sf IS NOT NULL AND gross_sf > 0
  )
  SELECT
    COALESCE(zip, 'UNKNOWN') AS zip,
    COALESCE(city, 'UNKNOWN') AS city,
    COUNT(*) AS sale_count,
    ROUND(AVG(ppsf)::DOUBLE, 2) AS avg_ppsf,
    ROUND(quantile_cont(ppsf, 0.5), 2) AS median_ppsf,
    MIN(sale_dt) AS first_sale,
    MAX(sale_dt) AS last_sale
  FROM base
  GROUP BY zip, city
  ORDER BY sale_count DESC
) TO '$OUTDIR/recent_ppsf.csv' (HEADER, DELIMITER ',');
.quit
SQL
      echo "Result: $OUTDIR/recent_ppsf.csv"
      ;;
    2)
      echo "--- Top Owners & Portfolios ---"
      duckdb <<SQL
$(make_load_prelude)
COPY (
  WITH inv AS (
    SELECT
      "$COL_OWNER" AS owner,
      TRY_CAST(
        REPLACE(
          REPLACE(CAST("$COL_GROSS_AREA" AS VARCHAR), ',', ''),
          '$', ''
        ) AS DOUBLE
      ) AS gross_sf
    FROM v_all
    WHERE "$COL_OWNER" IS NOT NULL
  ),
  agg AS (
    SELECT
      owner,
      COUNT(*) AS property_count,
      ROUND(SUM(COALESCE(gross_sf, 0))::DOUBLE, 0) AS total_sf
    FROM inv
    GROUP BY owner
  )
  SELECT owner, property_count, total_sf
  FROM agg
  ORDER BY property_count DESC, total_sf DESC
) TO '$OUTDIR/top_owners.csv' (HEADER, DELIMITER ',');
.quit
SQL
      echo "Result: $OUTDIR/top_owners.csv"
      ;;
    3)
      echo "--- Older Inventory & Value-Add Opportunities ---"
      duckdb <<SQL
$(make_load_prelude)
COPY (
  WITH office AS (
    SELECT
      "$COL_CITY" AS city,
      "$COL_ZIP" AS zip,
      yr_built,
      TRY_CAST(
        REPLACE(
          REPLACE(CAST("$COL_BUILDING_VALUE" AS VARCHAR), ',', ''),
          '$', ''
        ) AS DOUBLE
      ) AS bldg_val,
      TRY_CAST(
        REPLACE(CAST("$COL_GROSS_AREA" AS VARCHAR), ',', '')
        AS DOUBLE
      ) AS gross_sf
    FROM v_all
  ),
  buckets AS (
    SELECT *,
      CASE
        WHEN yr_built IS NULL THEN 'Unknown'
        WHEN yr_built < 1980 THEN 'Pre-1980'
        WHEN yr_built < 2000 THEN '1980-1999'
        WHEN yr_built < 2010 THEN '2000-2009'
        WHEN yr_built < 2020 THEN '2010-2019'
        ELSE '2020+'
      END AS era,
      CASE WHEN gross_sf > 0 THEN bldg_val / gross_sf END AS bldg_val_psf
    FROM office
  ),
  bench AS (
    SELECT zip, era,
      quantile_cont(bldg_val_psf, 0.25) AS p25_psf
    FROM buckets
    WHERE bldg_val_psf IS NOT NULL
    GROUP BY zip, era
  ),
  scored AS (
    SELECT b.*, be.p25_psf,
      CASE WHEN b.bldg_val_psf IS NOT NULL AND bldg_val_psf < be.p25_psf THEN 1 ELSE 0 END AS is_low
    FROM buckets b
    LEFT JOIN bench be ON b.zip = be.zip AND b.era = be.era
  )
  SELECT
    COALESCE(zip, 'UNKNOWN') AS zip,
    era,
    COUNT(*) AS prop_count,
    SUM(is_low) AS low_count,
    ROUND(AVG(bldg_val_psf)::DOUBLE, 2) AS avg_psf,
    ROUND(AVG(p25_psf)::DOUBLE, 2) AS bench_p25
  FROM scored
  GROUP BY zip, era
  HAVING SUM(is_low) > 0
  ORDER BY low_count DESC
) TO '$OUTDIR/value_add.csv' (HEADER, DELIMITER ',');
.quit
SQL
      echo "Result: $OUTDIR/value_add.csv"
      ;;
    4)
      echo "--- Out-of-Area Owners ---"
      duckdb <<SQL
$(make_load_prelude)
COPY (
  WITH own AS (
    SELECT
      "$COL_OWNER" AS owner,
      OwnerState AS owner_state,
      OwnerZip AS owner_zip,
      "$COL_ZIP" AS prop_zip
    FROM v_all
  )
  SELECT owner, owner_state, owner_zip,
         COUNT(*) AS count_props,
         LIST(DISTINCT prop_zips) AS prop_zips
  FROM own
  WHERE owner IS NOT NULL
  GROUP BY owner, owner_state, owner_zip
  ORDER BY count_props DESC
) TO '$OUTDIR/out_of_area.csv' (HEADER, DELIMITER ',');
.quit
SQL
      echo "Result: $OUTDIR/out_of_area.csv"
      ;;
    5)
      echo "--- Size Distribution ---"
      duckdb <<SQL
$(make_load_prelude)
COPY (
  WITH ofc AS (
    SELECT
      TRY_CAST(
        REPLACE(CAST("$COL_GROSS_AREA" AS VARCHAR), ',', '')
        AS DOUBLE
      ) AS gross_sf
    FROM v_all
  ),
  bins AS (
    SELECT
      CASE
        WHEN gross_sf < 5000 THEN 'Under 5,000'
        WHEN gross_sf < 15000 THEN '5,000–14,999'
        WHEN gross_sf < 50000 THEN '15,000–49,999'
        ELSE '50,000+'
      END AS size_bucket
    FROM ofc
    WHERE gross_sf IS NOT NULL
  )
  SELECT size_bucket,
         COUNT(*) AS props,
         ROUND(100.0 * COUNT(*) / SUM(COUNT(*)) OVER (), 2) AS pct
  FROM bins
  GROUP BY size_bucket
  ORDER BY
    CASE size_bucket
      WHEN 'Under 5,000' THEN 1
      WHEN '5,000–14,999' THEN 2
      WHEN '15,000–49,999' THEN 3
      ELSE 4
    END
) TO '$OUTDIR/size_dist.csv' (HEADER, DELIMITER ',');
.quit
SQL
      echo "Result: $OUTDIR/size_dist.csv"
      ;;
    6)
      echo "--- Underperforming Assets ---"
      duckdb <<SQL
$(make_load_prelude)
COPY (
  WITH ofc AS (
    SELECT
      "$COL_CITY" AS city,
      "$COL_ZIP" AS zip,
      yr_built,
      TRY_CAST(
        REPLACE(
          REPLACE(CAST("$COL_BUILDING_VALUE" AS VARCHAR), ',', ''),
          '$', ''
        ) AS DOUBLE
      ) / NULLIF(
        TRY_CAST(
          REPLACE(CAST("$COL_GROSS_AREA" AS VARCHAR), ',', '')
          AS DOUBLE
        ), 0
      ) AS bldg_psf
    FROM v_all
    WHERE "$COL_GROSS_AREA" IS NOT NULL AND "$COL_BUILDING_VALUE" IS NOT NULL
  ),
  bench AS (
    SELECT zip,
      quantile_cont(bldg_psf, 0.25) AS p25
    FROM ofc
    WHERE bldg_psf IS NOT NULL
    GROUP BY zip
  )
  SELECT o.city, o.zip, o.yr_built, o.bldg_psf, b.p25 AS bench_p25
  FROM ofc o
  JOIN bench b USING(zip)
  WHERE o.bldg_psf < b.p25
  ORDER BY zip, o.bldg_psf
) TO '$OUTDIR/underperforming.csv' (HEADER, DELIMITER ',');
.quit
SQL
      echo "Result: $OUTDIR/underperforming.csv"
      ;;
    7)
      echo "--- Transaction Volume / Hotspots ---"
      duckdb <<SQL
$(make_load_prelude)
COPY (
  WITH sales AS (
    SELECT
      "$COL_CITY" AS city,
      "$COL_ZIP" AS zip,
      TRY_CAST("$COL_SALE_DATE" AS DATE) AS sale_dt
    FROM v_all
    WHERE sale_dt >= (now() - INTERVAL '36 months')
  )
  SELECT
    COALESCE(zip, 'UNKNOWN') AS zip,
    COALESCE(city, 'UNKNOWN') AS city,
    DATE_TRUNC('year', sale_dt) AS year,
    COUNT(*) AS num_sales
  FROM sales
  GROUP BY zip, city, year
  ORDER BY year DESC, num_sales DESC
) TO '$OUTDIR/tx_volume.csv' (HEADER, DELIMITER ',');
.quit
SQL
      echo "Result: $OUTDIR/tx_volume.csv"
      ;;
    8)
      echo "--- Value Drivers (YearBuilt, Size, etc.) ---"
      duckdb <<SQL
$(make_load_prelude)
COPY (
  WITH sales AS (
    SELECT
      TRY_CAST("$COL_YEAR_BUILT" AS DOUBLE) AS yb,
      TRY_CAST(
        REPLACE(
          REPLACE(CAST("$COL_SALE_AMOUNT" AS VARCHAR), ',', ''),
          '$', ''
        ) AS DOUBLE
      ) / NULLIF(
        TRY_CAST(
          REPLACE(CAST("$COL_GROSS_AREA" AS VARCHAR), ',', '')
          AS DOUBLE
        ), 0
      ) AS ppsf
    FROM v_all
    WHERE ppsf IS NOT NULL
  ),
  corr AS (
    SELECT
      round(corr(yb, ppsf)::DOUBLE, 4) AS corr_year_ppsf
    FROM sales
  ),
  decades AS (
    SELECT
      CONCAT(CAST(FLOOR(yb/10)*10 AS VARCHAR), 's') AS decade,
      ppsf
    FROM sales
  ),
  med AS (
    SELECT
      CONCAT('median_ppsf_', decade) AS metric,
      round(quantile_cont(ppsf, 0.5), 2) AS value
    FROM decades
    GROUP BY decade
  )
  SELECT * FROM corr
  UNION ALL
  SELECT * FROM med
) TO '$OUTDIR/value_drivers.csv' (HEADER, DELIMITER ',');
.quit
SQL
      echo "Result: $OUTDIR/value_drivers.csv"
      ;;
    9)
      echo "--- Long-Term Ownership ---"
      duckdb <<SQL
$(make_load_prelude)
COPY (
  WITH inv AS (
    SELECT
      "$COL_OWNER" AS owner,
      TRY_CAST("$COL_SALE_DATE" AS DATE) AS sale_dt
    FROM v_all
  ),
  agg AS (
    SELECT
      owner,
      COUNT(*) AS count_props,
      SUM(CASE WHEN sale_dt IS NULL OR sale_dt < (now() - INTERVAL '10 years') THEN 1 ELSE 0 END) AS long_hold_count
    FROM inv
    WHERE owner IS NOT NULL
    GROUP BY owner
  )
  SELECT owner, count_props, long_hold_count
  FROM agg
  WHERE long_hold_count > 0
  ORDER BY long_hold_count DESC
) TO '$OUTDIR/long_term.csv' (HEADER, DELIMITER ',');
.quit
SQL
      echo "Result: $OUTDIR/long_term.csv"
      ;;
    *)
      echo "Invalid choice: $choice"
      ;;
  esac
done

echo "Done. All output in $OUTDIR"
